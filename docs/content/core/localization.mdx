
# Localization

The database schema fully supports multiple languages via separate translation tables. Translations are resolved at the **service layer** — services return flat, resolved objects so components can access `product.name` directly instead of digging into translation arrays.

## Language Configuration

The default language is defined in `src/lib/utils.ts`:

```typescript
import { DEFAULT_LANGUAGE } from "$lib/utils";

DEFAULT_LANGUAGE; // "en"
```

To change the default language for the entire application, update this single constant. All services and resolution utilities derive their default from it.

## Translation Tables

| Parent Table       | Translation Table              | Fields                        |
| ------------------ | ------------------------------ | ----------------------------- |
| `products`         | `product_translations`         | `name`, `slug`, `description` |
| `product_variants` | `product_variant_translations` | `name`                        |
| `facets`           | `facet_translations`           | `name`                        |
| `facet_values`     | `facet_value_translations`     | `name`                        |
| `collections`      | `collection_translations`      | `name`, `slug`, `description` |
| `categories`       | `category_translations`        | `name`                        |
| `content_pages`    | `content_page_translations`    | `title`, `slug`, `body`       |

Each translation table has a `languageCode` column (ISO 639-1, e.g. `"en"`, `"fi"`) with a unique index on `(parentId, languageCode)`.

## Service-Layer Resolution

Services resolve translations internally and return `Resolved*` types with flat translated fields. Components never need to pick translations manually.

```typescript
// Service returns a ResolvedProduct with flat fields
const product = await productService.getById(123);

product.name;        // "Blue Shirt" (resolved from translations)
product.slug;        // "blue-shirt"
product.description; // "<p>A nice shirt</p>"
product.translations; // Still available for editing forms
```

Services accept an optional `language` parameter (defaults to `DEFAULT_LANGUAGE`). Since only one language is currently used, you don't need to pass it.

### Resolution Utilities

The resolution functions live in `src/lib/server/i18n.ts`:

```typescript
import { resolveProduct, resolveCollection, resolveFacet } from "$lib/server/i18n";

// Each function takes an entity with translations[] and an optional language,
// and returns the entity with flat translated fields merged on
const resolved = resolveProduct(rawProduct, "en");
resolved.name; // "Blue Shirt"
```

Available resolution functions: `resolveProduct`, `resolveVariant`, `resolveFacet`, `resolveFacetValue`, `resolveCollection`, `resolveCategory`, `resolveCategoryTreeNode`, `resolveContentPage`.

### Resolved Types

`Resolved*` types extend the base types with flat translated fields while keeping `translations[]` intact:

```typescript
// ResolvedProduct extends Product
interface ResolvedProduct extends Product {
  name: string;
  slug: string;
  description: string | null;
  translations: ProductTranslation[]; // kept for editing
  variants: ResolvedProductVariant[];
  facetValues: ResolvedFacetValue[];
}
```

### Svelte Components

Components access translated fields directly — no helper functions needed:

```svelte
<script lang="ts">
  let { data } = $props();
</script>

<h1>{data.product.name}</h1>
<p>{data.collection.description}</p>
```

For admin forms that need to edit translations, the `translations` array is still available:

```svelte
<input name="name" value={data.product.name} />
<!-- translations[] available for multi-language editing -->
```

## Route Load Functions

Routes just call services — no language passthrough needed:

```typescript
export const load: PageServerLoad = async () => {
  const product = await productService.getById(123);
  const facets = await facetService.list();
  return { product, facets };
};
```

## Creating Translations

When creating or updating records, use `DEFAULT_LANGUAGE` for the language code:

```typescript
import { DEFAULT_LANGUAGE } from "$lib/utils";

await productService.create({
  translations: [{ languageCode: DEFAULT_LANGUAGE, name: "Blue Shirt", slug: "blue-shirt" }]
});
```

## Adding a New Language

1. No schema changes needed — translation tables already support any ISO 639-1 code
2. Add translations for the new language to existing records:

```typescript
await productService.update(productId, {
  translations: [{ languageCode: "fi", name: "Sininen paita", slug: "sininen-paita" }]
});
```

3. Add a language detection hook (URL prefix, cookie, or `Accept-Language` header) and pass the language to services

## Best Practices

1. **Never hardcode `"en"`** — always use `DEFAULT_LANGUAGE`
2. **Access flat fields in components** — use `product.name`, not `product.translations[0].name`
3. **Use `DEFAULT_LANGUAGE` in form actions** — when saving translations, reference the constant
4. **Don't pass language to services** — they default to `DEFAULT_LANGUAGE`. When multi-language is added, introduce a per-request language hook

See `src/lib/server/db/schema.ts` for translation table definitions and `src/lib/server/i18n.ts` for resolution utilities.

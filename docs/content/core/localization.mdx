
# Localization

Hoikka supports multiple languages. The default language (English) is stored directly on entity tables for simplicity, while non-default languages use separate translation tables.

## Language Configuration

Languages are configured in `src/lib/config/languages.ts`:

```typescript
import {
  DEFAULT_LANGUAGE,       // "en"
  LANGUAGES,              // [{ code: "en", name: "English" }, { code: "fi", name: "Suomi" }]
  TRANSLATION_LANGUAGES,  // [{ code: "fi", name: "Suomi" }] — excludes default
  translationsToMap       // Utility for components
} from "$lib/config/languages";
```

- **`DEFAULT_LANGUAGE`** — The language stored on entity tables (e.g. `products.name`)
- **`LANGUAGES`** — All supported languages
- **`TRANSLATION_LANGUAGES`** — Languages that use translation tables (everything except default)
- **`translationsToMap()`** — Converts translation rows into `Record<langCode, Record<field, value>>` for component consumption

## How It Works

### Default Language (English)

Default language fields live directly on entity tables:

```
products.name = "Blue Shirt"
products.slug = "blue-shirt"
products.description = "<p>A nice shirt</p>"
```

Services return these fields directly — no translation resolution needed:

```typescript
const product = await productService.getById(123);
product.name; // "Blue Shirt" — directly from the products table
```

### Non-Default Languages (Finnish, etc.)

Non-default languages are stored in translation tables and managed through the `TranslationService`:

```typescript
import { translationService } from "$lib/server/services/translations";

// Save a Finnish translation
await translationService.upsertProductTranslation(productId, "fi", {
  name: "Sininen paita",
  slug: "sininen-paita",
  description: "<p>Hieno paita</p>"
});

// Read translations
const rows = await translationService.getProductTranslations(productId);
// [{ languageCode: "fi", name: "Sininen paita", slug: "sininen-paita", ... }]
```

## Translation Tables

| Parent Table       | Translation Table              | Fields                        |
| ------------------ | ------------------------------ | ----------------------------- |
| `products`         | `product_translations`         | `name`, `slug`, `description` |
| `product_variants` | `product_variant_translations` | `name`                        |
| `facets`           | `facet_translations`           | `name`                        |
| `facet_values`     | `facet_value_translations`     | `name`                        |
| `collections`      | `collection_translations`      | `name`, `slug`, `description` |
| `categories`       | `category_translations`        | `name`                        |
| `content_pages`    | `content_page_translations`    | `title`, `slug`, `body`       |

Each translation table has a unique index on `(entity_id, language_code)`. The `TranslationService` uses Drizzle's `onConflictDoUpdate` for upserts.

## TranslationService

A single service (`src/lib/server/services/translations.ts`) handles all 7 entities with a consistent API:

```typescript
import { translationService } from "$lib/server/services/translations";

// Pattern: get + upsert per entity
await translationService.getProductTranslations(productId);
await translationService.upsertProductTranslation(productId, "fi", { name, slug, description });

await translationService.getVariantTranslations(variantId);
await translationService.upsertVariantTranslation(variantId, "fi", { name });

await translationService.getFacetTranslations(facetId);
await translationService.upsertFacetTranslation(facetId, "fi", { name });

await translationService.getAllFacetValueTranslations(facetId); // Bulk: all values for a facet
await translationService.upsertFacetValueTranslation(facetValueId, "fi", { name });

await translationService.getCollectionTranslations(collectionId);
await translationService.upsertCollectionTranslation(collectionId, "fi", { name, slug, description });

await translationService.getAllCategoryTranslations(); // Bulk: all categories
await translationService.upsertCategoryTranslation(categoryId, "fi", { name });

await translationService.getContentPageTranslations(pageId);
await translationService.upsertContentPageTranslation(pageId, "fi", { title, slug, body });
```

## Admin UI

### TranslationEditor Component

A reusable component (`src/lib/components/admin/TranslationEditor.svelte`) provides the translation editing UI for all entity admin pages:

```svelte
<script lang="ts">
  import TranslationEditor from "$lib/components/admin/TranslationEditor.svelte";
  import { translationsToMap } from "$lib/config/languages";
</script>

<TranslationEditor
  fields={[
    { name: "name", label: "Name", type: "text" },
    { name: "slug", label: "Slug", type: "text" },
    { name: "description", label: "Description", type: "richtext" }
  ]}
  translations={translationsToMap(data.translations)}
  entityId={data.product.id}
/>
```

**Props:**
- `fields` — Array of `{ name, label, type }` where type is `"text"`, `"textarea"`, or `"richtext"`
- `translations` — A `Record<langCode, Record<field, value>>` map (use `translationsToMap()` to convert from DB rows)
- `entityId` — The entity's ID
- `action` — Form action URL (defaults to `"?/saveTranslation"`)

**Behavior:**
- Renders a "Translations" card with a globe icon header
- Language tabs for each non-default language
- Posts to the `saveTranslation` action with `entityId`, `languageCode`, and field values
- Toast notification on save
- Hint text: "Leave empty to use the default (English) value."

### Wiring Pattern

Each admin edit page follows the same pattern:

**1. Load translations in `+page.server.ts`:**

```typescript
import { translationService } from "$lib/server/services/translations";

export const load = async ({ params }) => {
  const [product, translations] = await Promise.all([
    productService.getById(id),
    translationService.getProductTranslations(id)
  ]);
  return { product, translations };
};
```

**2. Add a `saveTranslation` action:**

```typescript
export const actions = {
  saveTranslation: async ({ request }) => {
    const formData = await request.formData();
    const entityId = Number(formData.get("entityId"));
    const languageCode = formData.get("languageCode") as string;
    const name = formData.get("name") as string;
    // ... other fields

    await translationService.upsertProductTranslation(entityId, languageCode, {
      name: name || "",
      slug: slug || "",
      description: description || null
    });
    return { translationSuccess: true };
  }
};
```

**3. Add `<TranslationEditor>` in `+page.svelte`:**

```svelte
<TranslationEditor
  fields={[
    { name: "name", label: "Name", type: "text" },
    { name: "slug", label: "Slug", type: "text" },
    { name: "description", label: "Description", type: "richtext" }
  ]}
  translations={translationsToMap(data.translations)}
  entityId={data.product.id}
/>
```

### Inline Translation Editing

For entities with inline editing (categories, facet values), Finnish name fields are added directly to the create/update forms instead of using the `TranslationEditor` component:

```svelte
<!-- Category inline edit -->
<input name="name_en" value={node.name} />
<input name="name_fi" value={categoryTranslations[node.id]?.fi?.name ?? ""} />
```

## Storefront Resolution

The storefront resolves translations at the service layer. Services accept an optional `language` parameter. When multi-language storefronts are needed, pass the detected language to service calls:

```typescript
// Future: detect language from URL prefix, cookie, or Accept-Language header
const product = await productService.getById(123, language);
```

## Adding a New Language

1. Add the language to `LANGUAGES` in `src/lib/config/languages.ts`
2. No schema changes needed — translation tables already support any language code
3. The admin UI automatically picks up the new language (TranslationEditor renders tabs for all `TRANSLATION_LANGUAGES`)
4. Add translations for existing records via the admin UI or programmatically via `TranslationService`

## Best Practices

1. **Never hardcode `"en"`** — always use `DEFAULT_LANGUAGE` from the config
2. **Default language fields go on entity tables** — `products.name`, not in `product_translations`
3. **Non-default translations go in translation tables** — managed via `TranslationService`
4. **Use `translationsToMap()`** — converts DB rows to the map format expected by `TranslationEditor`
5. **Leave translations empty to fall back** — the storefront uses entity table fields when no translation exists
